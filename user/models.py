from django.db import models
from django.contrib.auth.models import AbstractUser, BaseUserManager
from django.utils.html import strip_tags
from django.utils import timezone
from datetime import timedelta


class CustomUserManager(BaseUserManager):
    def create_user(self, email, first_name, last_name, password=None, **extra_fields):
        if not email:
            return ValueError('The email field must be set')
        email = self.normalize_email(email)
        user = self.model(email=email, first_name=first_name, last_name=last_name, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user
    
    def create_superuser(self, email, first_name, last_name, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True')
        return self.create_user(email, first_name, last_name, password, **extra_fields)


class CustomUser(AbstractUser):
    email = models.EmailField(unique=True, max_length=66)
    first_name = models.CharField(max_length=66)
    last_name = models.CharField(max_length=66)
    is_trener = models.BooleanField(default=False)
    phone = models.CharField(max_length=15, blank=True, null=True)
    username = models.CharField(max_length=150, unique=True, null=True, blank=True)
    experience_points = models.IntegerField(default=0)
    level = models.IntegerField(default=1)

    objects = CustomUserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['first_name', 'last_name']

    def __str__(self):
        return self.email
    
    def clean(self):
        for field in ['phone']:
            value = getattr(self, field)
            if value:
                setattr(self, field, strip_tags(value))
    
    def add_experience(self, points):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –æ–ø—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–≤—ã—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è"""
        self.experience_points += points
        self.check_level_up()
        self.save()
    
    def check_level_up(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –ø–æ–≤—ã—Å–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        points_needed = self.level * 100  # –ù–∞–ø—Ä–∏–º–µ—Ä, 100 –æ—á–∫–æ–≤ –Ω–∞ —É—Ä–æ–≤–µ–Ω—å
        if self.experience_points >= points_needed:
            self.level += 1
            # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è
            Notifications.objects.create(
                user=self,
                message=f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ {self.level} —É—Ä–æ–≤–Ω—è!"
            )
            return True
        return False
    
    def get_next_level_points(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è"""
        return (self.level * 100) - self.experience_points
    
    def get_total_progress_percentage(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—â–∏–π –ø—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Ü–µ–ª–µ–π"""
        progress_entries = UserProgress.objects.filter(user=self, is_completed=True)
        if not progress_entries.exists():
            return 0
        return int((progress_entries.count() / UserProgress.objects.filter(user=self).count()) * 100)


class ProgressCategory(models.Model):
    CATEGORY_TYPES = [
        ('fitness', 'üèãÔ∏è –§–∏—Ç–Ω–µ—Å'),
        ('nutrition', 'ü•ó –ü–∏—Ç–∞–Ω–∏–µ'),
        ('health', 'üíä –ó–¥–æ—Ä–æ–≤—å–µ'),
        ('lifestyle', 'üåø –û–±—Ä–∞–∑ –∂–∏–∑–Ω–∏'),
        ('personal', 'üéØ –õ–∏—á–Ω—ã–µ —Ü–µ–ª–∏'),
    ]
    
    name = models.CharField(max_length=100, verbose_name="–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏")
    icon = models.CharField(max_length=20, default="‚≠ê", verbose_name="–ò–∫–æ–Ω–∫–∞")
    category_type = models.CharField(max_length=20, choices=CATEGORY_TYPES, verbose_name="–¢–∏–ø –∫–∞—Ç–µ–≥–æ—Ä–∏–∏")
    description = models.TextField(blank=True, verbose_name="–û–ø–∏—Å–∞–Ω–∏–µ")
    is_active = models.BooleanField(default=True, verbose_name="–ê–∫—Ç–∏–≤–Ω–∞")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è")

    class Meta:
        verbose_name = "–ö–∞—Ç–µ–≥–æ—Ä–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"
        verbose_name_plural = "–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"
        ordering = ['category_type', 'name']

    def __str__(self):
        return f"{self.icon} {self.name}"


class UserProgress(models.Model):
    PROGRESS_STATUS = [
        ('not_started', '–ù–µ –Ω–∞—á–∞—Ç–æ'),
        ('in_progress', '–í –ø—Ä–æ—Ü–µ—Å—Å–µ'),
        ('completed', '–ó–∞–≤–µ—Ä—à–µ–Ω–æ'),
        ('failed', '–ù–µ —É–¥–∞–ª–æ—Å—å'),
    ]
    
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='progress_entries')
    category = models.ForeignKey(ProgressCategory, on_delete=models.CASCADE, verbose_name="–ö–∞—Ç–µ–≥–æ—Ä–∏—è")
    title = models.CharField(max_length=200, verbose_name="–ù–∞–∑–≤–∞–Ω–∏–µ —Ü–µ–ª–∏")
    description = models.TextField(blank=True, verbose_name="–û–ø–∏—Å–∞–Ω–∏–µ —Ü–µ–ª–∏")
    target_value = models.DecimalField(max_digits=10, decimal_places=2, verbose_name="–¶–µ–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ")
    current_value = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name="–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ")
    unit = models.CharField(max_length=20, default="—Ä–∞–∑", verbose_name="–ï–¥–∏–Ω–∏—Ü–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è")
    status = models.CharField(max_length=20, choices=PROGRESS_STATUS, default='not_started', verbose_name="–°—Ç–∞—Ç—É—Å")
    priority = models.IntegerField(default=1, choices=[(1, '–ù–∏–∑–∫–∏–π'), (2, '–°—Ä–µ–¥–Ω–∏–π'), (3, '–í—ã—Å–æ–∫–∏–π')], verbose_name="–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç")
    start_date = models.DateField(default=timezone.now, verbose_name="–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞")
    end_date = models.DateField(null=True, blank=True, verbose_name="–î–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è")
    is_completed = models.BooleanField(default=False, verbose_name="–ó–∞–≤–µ—Ä—à–µ–Ω–æ")
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name="–î–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="–î–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")

    class Meta:
        verbose_name = "–ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
        verbose_name_plural = "–ü—Ä–æ–≥—Ä–µ—Å—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
        ordering = ['-priority', '-created_at']

    def __str__(self):
        return f"{self.user.email} - {self.title}"
    
    def save(self, *args, **kwargs):
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∑–Ω–∞—á–µ–Ω–∏–π
        if self.current_value >= self.target_value and not self.is_completed:
            self.status = 'completed'
            self.is_completed = True
            self.completed_at = timezone.now()
            
            # –ù–∞–≥—Ä–∞–∂–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–ø—ã—Ç–æ–º
            experience_points = int(self.target_value * self.priority)
            self.user.add_experience(experience_points)
            
            # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ü–µ–ª–∏
            Notifications.objects.create(
                user=self.user,
                message=f"üéØ –¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞: {self.title}! +{experience_points} –æ–ø—ã—Ç–∞"
            )
        
        elif self.current_value > 0 and self.status == 'not_started':
            self.status = 'in_progress'
        
        super().save(*args, **kwargs)
    
    @property
    def progress_percentage(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ü–µ–ª–∏"""
        if self.target_value == 0:
            return 0
        return min(100, int((float(self.current_value) / float(self.target_value)) * 100))
    
    @property
    def days_remaining(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –¥–Ω–µ–π"""
        if self.end_date and not self.is_completed:
            remaining = (self.end_date - timezone.now().date()).days
            return max(0, remaining)
        return None
    
    @property
    def is_overdue(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–∞ –ª–∏ —Ü–µ–ª—å"""
        if self.end_date and not self.is_completed:
            return timezone.now().date() > self.end_date
        return False


class ProgressUpdate(models.Model):
    progress = models.ForeignKey(UserProgress, on_delete=models.CASCADE, related_name='updates')
    value_added = models.DecimalField(max_digits=10, decimal_places=2, verbose_name="–î–æ–±–∞–≤–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ")
    notes = models.TextField(blank=True, verbose_name="–ó–∞–º–µ—Ç–∫–∏")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="–î–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")

    class Meta:
        verbose_name = "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"
        verbose_name_plural = "–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"
        ordering = ['-created_at']

    def __str__(self):
        return f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ {self.progress.title} - +{self.value_added}"


class Achievement(models.Model):
    ACHIEVEMENT_TYPES = [
        ('workout', '–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏'),
        ('service', '–£—Å–ª—É–≥–∏'),
        ('shopping', '–ü–æ–∫—É–ø–∫–∏'),
        ('social', '–°–æ—Ü–∏–∞–ª—å–Ω—ã–µ'),
        ('system', '–°–∏—Å—Ç–µ–º–Ω—ã–µ'),
        ('progress', '–ü—Ä–æ–≥—Ä–µ—Å—Å'),
    ]
    
    name = models.CharField(max_length=100, verbose_name="–ù–∞–∑–≤–∞–Ω–∏–µ")
    description = models.TextField(verbose_name="–û–ø–∏—Å–∞–Ω–∏–µ")
    icon = models.CharField(max_length=50, default="üèÜ", verbose_name="–ò–∫–æ–Ω–∫–∞")
    achievement_type = models.CharField(max_length=20, choices=ACHIEVEMENT_TYPES, verbose_name="–¢–∏–ø –∞—á–∏–≤–∫–∏")
    points_reward = models.IntegerField(default=10, verbose_name="–ù–∞–≥—Ä–∞–¥–∞ –≤ –æ—á–∫–∞—Ö")
    requirement = models.IntegerField(default=1, verbose_name="–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ")
    is_active = models.BooleanField(default=True, verbose_name="–ê–∫—Ç–∏–≤–Ω–∞")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è")

    class Meta:
        verbose_name = "–ê—á–∏–≤–∫–∞"
        verbose_name_plural = "–ê—á–∏–≤–∫–∏"
        ordering = ['achievement_type', 'requirement']

    def __str__(self):
        return f"{self.icon} {self.name}"


class UserAchievement(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='achievements')
    achievement = models.ForeignKey(Achievement, on_delete=models.CASCADE)
    progress = models.IntegerField(default=0, verbose_name="–ü—Ä–æ–≥—Ä–µ—Å—Å")
    is_unlocked = models.BooleanField(default=False, verbose_name="–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞")
    unlocked_at = models.DateTimeField(null=True, blank=True, verbose_name="–î–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è")

    class Meta:
        verbose_name = "–ê—á–∏–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
        verbose_name_plural = "–ê—á–∏–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
        unique_together = ['user', 'achievement']
        ordering = ['-unlocked_at', '-created_at']

    def __str__(self):
        return f"{self.user.email} - {self.achievement.name}"
    
    def update_progress(self, amount=1):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å –∞—á–∏–≤–∫–∏"""
        if not self.is_unlocked:
            self.progress += amount
            if self.progress >= self.achievement.requirement:
                self.unlock()
            self.save()
    
    def unlock(self):
        """–†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç –∞—á–∏–≤–∫—É –∏ –Ω–∞–≥—Ä–∞–∂–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        if not self.is_unlocked:
            self.is_unlocked = True
            self.unlocked_at = timezone.now()
            self.user.add_experience(self.achievement.points_reward)
            
            # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞—á–∏–≤–∫–∏
            Notifications.objects.create(
                user=self.user,
                message=f"üéñÔ∏è –ü–æ–ª—É—á–µ–Ω–∞ –∞—á–∏–≤–∫–∞: {self.achievement.name}! +{self.achievement.points_reward} –æ–ø—ã—Ç–∞"
            )
    
    @property
    def progress_percentage(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞—á–∏–≤–∫–∏"""
        if self.achievement.requirement == 0:
            return 100
        return min(100, int((self.progress / self.achievement.requirement) * 100))


class Notifications(models.Model):
    is_active = models.BooleanField(default=True)
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    message = models.CharField(max_length=1000)
    created_at = models.DateTimeField(auto_now_add=True)
    deleted_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        verbose_name = "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"
        verbose_name_plural = "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"
        ordering = ['-created_at']
    
    def __str__(self):
        return f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è {self.user}: {self.message[:50]}..."
    
    def save(self, *args, **kwargs):
        if not self.pk and not self.deleted_at:
            self.deleted_at = timezone.now() + timedelta(days=1)
        super().save(*args, **kwargs)
    
    @property
    def is_expired(self):
        return timezone.now() >= self.deleted_at if self.deleted_at else False